---
layout: post
category: 后端
---


##三种查找算法:顺序查找，二分法查找（折半查找），分块查找，散列表（以后谈）
![](/assets/img/14770183551087.jpg)

##一、顺序查找的基本思想：
从表的一端开始，顺序扫描表，依次将扫描到的结点关键字和给定值（假定为a）相比较，若当前结点关键字与a相等，则查找成功；若扫描结束后，仍未找到关键字等于a的结点，则查找失败。
 
说白了就是，从头到尾，一个一个地比，找着相同的就成功，找不到就失败。很明显的缺点就是查找效率低。
 
适用于线性表的顺序存储结构和链式存储结构。
![](/assets/img/14770183829468.jpg)


计算平均查找长度。
例如上表，查找1，需要1次，查找2需要2次，依次往下推，可知查找16需要16次，
可以看出，我们只要将这些查找次数求和（我们初中学的，上底加下底乘以高除以2），然后除以结点数，即为平均查找长度。
设n=节点数
平均查找长度=（n+1）/2
 
##二、二分法查找（折半查找）的基本思想： 
前提：
（1）确定该区间的中点位置：mid=（low+high）/2    
min代表区间中间的结点的位置，low代表区间最左结点位置，high代表区间最右结点位置
（2）将待查a值与结点mid的关键字（下面用R[mid].key）比较，若相等，则查找成功，否则确定新的查找区间：
如果R[mid].key>a，则由表的有序性可知，R[mid].key右侧的值都大于a，所以等于a的关键字如果存在，必然在R[mid].key左边的表中。这时high=mid-1
如果R[mid].key<a,则等于a的关键字如果存在，必然在R[mid].key右边的表中。这时low=mid
如果R[mid].key=a，则查找成功。
（3）下一次查找针对新的查找区间，重复步骤（1）和（2）
（4）在查找过程中，low逐步增加，high逐步减少，如果high<low，则查找失败。
![](/assets/img/14770184002175.jpg)


平均查找长度=Log2(n+1)-1
 
注：虽然二分法查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算，所以二分法比较适用于顺序存储结构。为保持表的有序性，在顺序结构中插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动而又经常需要查找的线性表。
 
##三、分块查找的基本思想：
 
二分查找表使分块有序的线性表和索引表（抽取各块中的最大关键字及其起始位置构成索引表
）组成，由于表是分块有序的，所以索引表是一个递增有序表，因此采用顺序或二分查找索引表，以确定待查结点在哪一块，由于块内无序，只能用顺序查找。
 ![](/assets/img/14770184101873.jpg)
 
设表共n个结点，分b块，s=n/b
(分块查找索引表)平均查找长度=Log2（n/s+1）+s/2
(顺序查找索引表)平均查找长度=(S2+2S+n)/(2S)
 
 
注：分块查找的优点是在表中插入或删除一个记录时，只要找到该记录所属块，就在该块中进行插入或删除运算（因块内无序，所以不需要大量移动记录）。它主要代价是增加一个辅助数组的存储控件和将初始表分块排序的运算。
 
它的性能介于顺序查找和二分查找之间。


![](/assets/img/14770182698908.jpg)


