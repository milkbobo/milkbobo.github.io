---
layout: post
category: 数据结构与算法
---

# 树（Tree）
树，顾名思义，长得像一棵树，不过通常我们画成一棵倒过来的树，根在上，叶在下。不说那么多了，图一看就懂：
![](/assets/img/14813498522339.png)

当然了，引入了树之后，就不得不引入树的一些概念，这些概念我照样尽量用图，谁会记那么多文字？
![](/assets/img/14813498591450.png)

树这种结构还可以表示成下面这种方式，可见树用来描述包含关系是很不错的，但这种包含关系不得出现交叉重叠区域，否则就不能用树描述了，看图：
![](/assets/img/14813498674018.png)

面试的时候我们经常被考到的是一种叫“二叉树”的结构，二叉树当然也是树的一种了，它的特点是除了叶以外的节点都有两个子，图：
![](/assets/img/14813498800479.png)

由此我们还可以推出“三叉树”：
![](/assets/img/14813498912073.png)

当然还有“四叉树”，“五叉树”，“六叉树”……但太难画了，节点太多，略过。

# 二叉树

## 二叉树具有如下性质的非空二叉树：
1. 若左子树不为空，左子树的所有结点的值均小于根的值；
2. 若右子树不为空，右子树的所有结点均大于根的值；
3. 它的左右子树也分别为二叉排序树。

每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，期望O(logn),最坏O(n)(数列有序,树退化成线性表).
虽然二叉排序树的最坏效率是O(n),但它支持动态查询,且有很多改进版的二叉排序树可以使树高为O(logn),如SBT,AVL,红黑树等.故不失为一种好的动态排序方法.

## 在二叉排序树b中查找x的过程为：
1.	若b是空树，则搜索失败，否则：
2.	若x等于b的根节点的数据域之值，则查找成功；否则：
3.	若x小于b的根节点的数据域之值，则搜索左子树；否则：
4.	查找右子树。

## 在二叉排序树插入结点的算法
### 向一个二叉排序树b中插入一个结点s的算法，过程为：
1. 若b是空树，则将s所指结点作为根结点插入，否则：
2.	若s->data等于b的根结点的数据域之值，则返回，否则：
3.	若s->data小于b的根结点的数据域之值，则把s所指结点插入到左子树中，否则：
4.	把s所指结点插入到右子树中。

## 在二叉排序树删除结点的算法
### 在二叉排序树删去一个结点，分三种情况讨论：
1.	若p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
2.	若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树即可，作此修改也不破坏二叉排序树的特性。
3.	删除的节点既有左子树也有右子树的情况。
	第一步：查找删除结点右子树中最小的那个值，也就是右子树中位于最左方的那个结点。然后将这个结点的值的父节点记录下来。并且将该节点的值赋给我们要删除的结点。也就是覆盖。 	第二步：然后将右子树中最小的那个结点进行删除，该节点肯定符合上述三种情况的某一种情况，所以可以使用上述的方法进行删除。
	
### 演示
[http://zh.visualgo.net/bst] 
# 红黑树

## 简介
红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
	
## 特性
### 红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶节点（NIL节点，空节点）是黑色的。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
	
## 演示
[http://sandbox.runjs.cn/show/2nngvn8w]
[http://blog.csdn.net/hackooo/article/details/10161393]

# 哈夫曼树
哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明。
利用霍夫曼树可以构成最佳判定过程。判定过程可以看成二叉树以开始判断作为根结点,判断的结果分成二叉 ,再对其中的分支作进一步的判断。如果将权值大的比较放的深度较深,那么整棵比较树的权值就会加大, 此只有将权值大的比较放在深度较浅处,将权值小的比较放在深度较深处,那么整棵比较树的权值就变小,总的判 定次数就比较少。这种优化的思想就是尽量降低整棵树 的权值,这就是最优二叉树的原理。

## 一般可以按下面步骤构建：
1. 将所有左，右子树都为空的作为根节点。
2. 在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。
3. 从森林中删除这两棵树，同时把新树加入到森林中。
4. 重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。

### 下面是构建哈夫曼树的图解过程：
![](/assets/img/14825613113082.jpg)

### 例子
![](/assets/img/14836905416649.jpg)
![](/assets/img/14836905542538.jpg)
![](/assets/img/14836905678885.jpg)
![](/assets/img/14836905842360.jpg)
[http://www.docin.com/p-442541094.html]

# 满二叉树：
* 一颗深度为k且有2^k-1个结点的二叉树称为满二叉树。
* 除叶子结点外的所有结点均有两个子结点。节点数达到最大值。所有叶子结点必须在同一层上。
* 满二叉树是指这样的一种二叉树：除最后一层外，每一层上的所有结点都有两个子结点。在满二叉树中，每一层上的结点数都达到最大值，即在满二叉树的第k层上有2k-1个结点，且深度为m的满二叉树有2m－1个结点。
      
# 完全二叉树：
* 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

# 区别：
* 满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树。

满二叉树
![](/assets/img/14825637514720.jpg)

完全二叉树
![](/assets/img/14825637576152.jpg)


# B树、B-树、B+树、B*树 红黑树
[http://blog.csdn.net/quitepig/article/details/8041308]





