---
layout: post
category: 数据结构与算法
---

# 树（Tree）
树，顾名思义，长得像一棵树，不过通常我们画成一棵倒过来的树，根在上，叶在下。不说那么多了，图一看就懂：
![](/assets/img/14813498522339.png)

当然了，引入了树之后，就不得不引入树的一些概念，这些概念我照样尽量用图，谁会记那么多文字？
![](/assets/img/14813498591450.png)

树这种结构还可以表示成下面这种方式，可见树用来描述包含关系是很不错的，但这种包含关系不得出现交叉重叠区域，否则就不能用树描述了，看图：
![](/assets/img/14813498674018.png)

面试的时候我们经常被考到的是一种叫“二叉树”的结构，二叉树当然也是树的一种了，它的特点是除了叶以外的节点都有两个子，图：
![](/assets/img/14813498800479.png)

由此我们还可以推出“三叉树”：
![](/assets/img/14813498912073.png)

当然还有“四叉树”，“五叉树”，“六叉树”……但太难画了，节点太多，略过。

二叉树具有如下性质的非空二叉树：
 （1）若左子树不为空，左子树的所有结点的值均小于根的值；
 （2）若右子树不为空，右子树的所有结点均大于根的值；
 （3）它的左右子树也分别为二叉排序树。

每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，期望O(logn),最坏O(n)(数列有序,树退化成线性表).
虽然二叉排序树的最坏效率是O(n),但它支持动态查询,且有很多改进版的二叉排序树可以使树高为O(logn),如SBT,AVL,红黑树等.故不失为一种好的动态排序方法.

在二叉排序树b中查找x的过程为：
	1.	若b是空树，则搜索失败，否则：
	2.	若x等于b的根节点的数据域之值，则查找成功；否则：
	3.	若x小于b的根节点的数据域之值，则搜索左子树；否则：
	4.	查找右子树。

在二叉排序树插入结点的算法
向一个二叉排序树b中插入一个结点s的算法，过程为：
	1.	若b是空树，则将s所指结点作为根结点插入，否则：
	2.	若s->data等于b的根结点的数据域之值，则返回，否则：
	3.	若s->data小于b的根结点的数据域之值，则把s所指结点插入到左子树中，否则：
	4.	把s所指结点插入到右子树中。

在二叉排序树删除结点的算法
在二叉排序树删去一个结点，分三种情况讨论：
	1.	若*p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
	2.	若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树即可，作此修改也不破坏二叉排序树的特性。
	3.	若*p结点的左子树和右子树均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令*p的左子树为*f的左子树，*s为*f左子树的最右下的结点，而*p的右子树为*s的右子树；其二是令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。在二叉排序树上删除一个结点的算法如下：

http://zh.visualgo.net/bst

